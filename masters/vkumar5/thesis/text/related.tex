There are several categories of related work.  First, we have the
immediate work upon which we are building.  The \mclab project already
provided the front-end and the \mcsaf\cite{JesseThesis} analysis
framework, which provided an important basis for the Tamer.  
Then there is \mcfor, a previous attempt to build a static
compiler targeting {\sc FORTRAN95}, that is part of the \mclab project.
There are also other compilers for \matlab, both static ones and
dynamic ones.
\
There is also related work on statically analyzing and compiling
other dynamic languages, with some similar problems we have faced,
and some similar approaches. Some of this work is presented
in section \secref{sec:otherStatic}.

\section{\mcfor}

We learned a lot from \mclab's previous \mcfor project\cite{McForThesis}
which was a first prototype \matlab to {\sc FORTRAN95}
compiler.  \mcfor supported a smaller subset of the language, and
simply ignored unsupported features - leading to possibly undefined
behavior. \mcfor did also not have a comprehensive approach to the
builtin functions, did not support the \matlab function lookup semantics, and
had a much more ad hoc approach to the analyses.  However, it really
showed that conversion of \matlab to {\sc FORTRAN95} was possible, and
that {\sc FORTRAN95} is an excellent target language.
In particular it showed that the numerical and matrix features
of {\sc FORTRAN95} are a good match for compiled \matlab, and that
the static nature of the language, together with powerful
{\sc FORTRAN95} compilers provide the potential for high performance.

We have developed the Tamer with targeting {\sc FORTRAN95} in mind. In
order to provide some extra flexibility for other potential backends
we have restricted \matlab less than may be necessary for a \matlab to
{\sc FORTRAN} compiler, i.e. it may have to restrict the \matlab
language further. For example, {\sc FORTRAN95} has very limited
polymorphism support, meaning that any polymorphic code can not be
easily \rednote{translated} to compact and readable FORTRAN. \mcfor does observe
these limitations, but does have an interesting way to deal with one
polymorphic case: If an if-statement results in incompatible types for
a variable along both branches, the code following that if-statement
gets copied into both branches, so that there won't be a confluence of
incompatible types.  For example,
\vspace{-.5cm}
\begin{lstlisting}
if (...)
  x = 3
else
  x = 'Hi'
end
foo(x)
\end{lstlisting}
may be converted to
\vspace{-.5cm}
\begin{lstlisting}
if (...)
  x = 3
  foo(x)
else
  x = 'Hi'
  foo(x)
end
\end{lstlisting}
This transformation is not possible in general for confluence points around
loop statements, and does also not work if values with ambiguous types
are returned from a function.

Despite being a full compiler with many interesting ideas, \mcfor is a
prototype, with limited feature set and limited extensibility. For
this thesis we have gone back to the basics and defined a much larger
subset of \matlab, taken a more structured and extensible approach to
building a general toolkit, tackled the problem of a principled
approach to the builtins, and defined the interprocedural analyses in
a more rigorous and extensible fashion.  The next generation of \mcfor
can now be built upon these new foundations.

\section{Other Static \matlab compilers}

Although we were not able to find publicly available versions, there
have been several excellent previous research projects on static
compilation of \matlab which focused particularly on the array-based
subset of \matlab and developed advanced static analyses for
determining shapes and sizes of arrays.  For example,
FALCON \cite{falcon} is a \matlab to {\sc FORTRAN90} translator with
sophisticated type inference algorithms.  Our Tamer is targeting a
larger and more modern set of \matlab that includes other types of
data structures such as cell arrays and structs, function handles and
lambda expressions, and which obeys the modern semantics of \matlab7.
We should note that FALCON handled interprocedural issues by fully
in-lining all of the the code.  MaJIC\cite{MaJIC}, a MATLAB
Just-In-Time compiler, is patterned after FALCON.  It uses similar
type inference techniques to FALCON, but are simplified to fit the JIT
context.  MAGICA \cite{Joisha03,MAGICA} is a type inference engine
developed by Joisha and Banerjee of Northwestern University, and is
written in Mathematica and is designed as an add-on module used by
MAT2C compiler \cite{MAT2C}.  We hope to learn from the advanced type
inference approaches in these projects and to implement similar
approximations using our interprocedural value analysis.

There are also commercial compilers, which are not publicly available, and for
which there are no research articles.   One such product is the \textit{MATLABCoder} 
recently released by MathWorks\cite{MATLABCoder}.   This product
produces C code for a subset of \matlab.  According to our preliminary tests,
this product does not appear to support cell arrays except in very
specific circumstances, nor does it support a general form of lambda
expressions, and was therefore unable to handle quite a few of our benchmarks.  
However, the key differences with our work is that we are
designing and providing an extensible and open source toolkit for compiler and
tool researchers.   This is clearly not the main goal of proprietary compilers.

\section{Other \matlab-like systems}

There are other projects providing open source implementations of \matlab-like
languages, such as Octave\cite{Octave} and Scilab\cite{Scilab}.   Although
these add valuable contributions to the open source community,  
their focus is on providing interpreters and open library support and they have
not tackled the problems of static compilation.   Thus, we believe that our
contributions are complementary. In particular Octave may present opportunities
to improve the usefulness of our static compiler framework without requiring
an actual \matlab installation.
 Octave, being an interpreter system, may not provide very high
performance, but it does include a large library similar to \matlab's
library. Enabling our framework to support Octave's specific \matlab flavor
may help bring together Octave's completeness with the potential performance
gains of a static compilation framework.


\section{Static Approaches to other Dynamic Languages}
\label{sec:otherStatic}

Other dynamic languages have had very successful efforts in defining
static subsets in order to provide static analysis.

\subsection{Python}

Reduced Python (RPython)\cite{RPython} provided inspiration for our
approach at dealing with a dynamic language in a static way. Rather
than attempting to support dynamic features that are not amenable to
static compilation, for example by providing interpreter-like features
as a fallback, RPython restricts (``reduces'') the set of allowable features such
that programs are statically typable. At the same time, it attempts to
stay as expressive as possible.

RPython was originally developed for PyPy, a Python interpreter written \rednote{in} Python,
but has evolved into be a general purpose language.
It was not developed to compile programs completely statically,
but rather with the goal to speed up execution times in 
virtual machines like VM or CLI, which are themselves developed
for static languages (Java and C\#, respectively).

%boot strapping phase?

Besides disallowing dynamic features, RPython disallows a basic feature
of many dynamic programing languages: at a confluence point,
a variable may not be defined with two incompatible types. This
notion that a variable should have one specific type at every programming
point is something that we expect for static backends of our framework
as well, in particular for FORTRAN, even if the Tamer Framework itself
actually supports union types. Both RPython, as well as our own research
have indicated that this restriction is not a serious limitation in practice.

RPython restricts Python's container types. In particular, it forces
that dictionaries (hash-tables) and arrays are homogeneous, i.e. all
elements have the same type. Tuples are allowed to be inhomogeneous.
For the Tamer, we represent the two builtin container types (structs,
cells) in both possible ways: as a tuple or as a collection, which correspond to
inhomogeneous and homogeneous representations, respectively.

RPython does not directly support generic functions, i.e. if a function
is used multiple times with incompatible arguments, the program
gets rejected. The Tamer uses a context-sensitive interprocedural
analysis that creates copies of functions when they are called
with incompatible arguments.


\subsection{Ruby}
DiamondbackRuby (DRuby) is a static type inference toolkit for Ruby
\cite{StaticRuby}, mostly with the goal to gain the advantage of static languages
to report potential errors ahead of time.  Ruby, like \matlab, is a
dynamic, interpreted language, but is used more in web
development. Some of the approaches of DRuby are similar to the Tamer
framework.

Similar to \matlab, the core library of Ruby is written in native code
(i.e. in C), rather than Ruby itself - which may also have different
behaviors depending on the incoming argument types. Thus DRuby has to
provide type information for builtin functions. In order to that,
DRuby includes a type annotation language, which can also be used to
specify types for functions with difficult behavior. Note that at this
point, the focus of our builtin framework is to organize the large
number of builtins, but our work may lead to a proper type annotation
language as well.

DRuby also provides a type inference, but it is based on a
constraint-based analysis. DRuby constrains the set of supported
language features to enable the static analysis, but allows some of
them by inserting runtime checks to still be able to support them.
These are included in such a way as to help users identify where
exactly the error occurred.

Using the results of the static analyses provided by the \matlab Tamer
to provide information about potential runtime errors is one
of the possible goals of continued research.
